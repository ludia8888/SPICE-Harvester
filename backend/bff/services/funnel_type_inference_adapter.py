"""
ğŸ”¥ THINK ULTRA! Funnel HTTP Type Inference Service Adapter
HTTP ê¸°ë°˜ Funnel ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ë¥¼ TypeInferenceInterfaceë¡œ adapting
"""

import logging
from typing import Any, Dict, List, Optional

from shared.interfaces.type_inference import ColumnAnalysisResult as InterfaceColumnResult
from shared.interfaces.type_inference import TypeInferenceInterface
from shared.interfaces.type_inference import TypeInferenceResult as InterfaceTypeResult

from bff.services.funnel_client import FunnelClient

logger = logging.getLogger(__name__)


class FunnelHTTPTypeInferenceAdapter(TypeInferenceInterface):
    """
    HTTP ê¸°ë°˜ Funnel ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ë¥¼ TypeInferenceInterfaceë¡œ adaptingí•˜ëŠ” í´ë˜ìŠ¤.

    FunnelClientë¥¼ ì‚¬ìš©í•˜ì—¬ Funnel ì„œë¹„ìŠ¤ì™€ HTTP í†µì‹ í•˜ë©°,
    ê²°ê³¼ë¥¼ TypeInferenceInterface í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    """

    def __init__(self, funnel_client: FunnelClient = None):
        self.funnel_client = funnel_client or FunnelClient()

    async def infer_column_type(
        self,
        column_data: List[Any],
        column_name: Optional[str] = None,
        include_complex_types: bool = False,
        context_columns: Optional[Dict[str, List[Any]]] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> InterfaceColumnResult:
        """
        ë‹¨ì¼ ì»¬ëŸ¼ ë°ì´í„°ì˜ íƒ€ì…ì„ ì¶”ë¡ í•©ë‹ˆë‹¤.
        """
        if metadata:
            include_complex_types = metadata.get("include_complex_types", include_complex_types)

        # HTTP ê¸°ë°˜ ë¶„ì„ì„ ìœ„í•´ ë°ì´í„°ë¥¼ dataset í˜•íƒœë¡œ ë³€í™˜
        data = [[value] for value in column_data]
        headers = [column_name or "column_0"]

        result = await self._analyze_single_column(data, headers, include_complex_types)

        if result and len(result) > 0:
            return result[0]
        else:
            # ê¸°ë³¸ê°’ ë°˜í™˜
            total_count = len(column_data)
            non_empty_values = [v for v in column_data if v is not None and str(v).strip() != ""]
            non_empty_count = len(non_empty_values)
            null_count = total_count - non_empty_count
            unique_count = len(set(str(v) for v in non_empty_values))
            null_ratio = null_count / total_count if total_count > 0 else 0.0
            unique_ratio = unique_count / non_empty_count if non_empty_count > 0 else 0.0

            return InterfaceColumnResult(
                column_name=column_name or "column_0",
                inferred_type=InterfaceTypeResult(
                    type="xsd:string", confidence=0.5, reason="Default type inference failed"
                ),
                total_count=total_count,
                non_empty_count=non_empty_count,
                sample_values=non_empty_values[:10],
                null_count=null_count,
                unique_count=unique_count,
                null_ratio=null_ratio,
                unique_ratio=unique_ratio,
            )

    async def analyze_dataset(
        self,
        data: List[List[Any]],
        columns: List[str],
        sample_size: int = 1000,
        include_complex_types: bool = False,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> List[InterfaceColumnResult]:
        """
        ì „ì²´ ë°ì´í„°ì…‹ì„ ë¶„ì„í•˜ì—¬ ëª¨ë“  ì»¬ëŸ¼ì˜ íƒ€ì…ì„ ì¶”ë¡ í•©ë‹ˆë‹¤.
        """
        if metadata:
            include_complex_types = metadata.get("include_complex_types", include_complex_types)
            sample_size = metadata.get("sample_size", sample_size)

        return await self._analyze_dataset_async(data, columns, include_complex_types, sample_size)

    async def infer_type_with_confidence(
        self, values: List[Any], check_complex: bool = False
    ) -> InterfaceTypeResult:
        """
        ê°’ ë¦¬ìŠ¤íŠ¸ì—ì„œ íƒ€ì…ì„ ì¶”ë¡ í•˜ê³  ì‹ ë¢°ë„ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
        """
        column_result = await self.infer_column_type(
            values, column_name="temp", include_complex_types=check_complex
        )

        return column_result.inferred_type

    async def infer_single_value_type(
        self, value: Any, context: Optional[Dict[str, Any]] = None
    ) -> InterfaceTypeResult:
        """
        ë‹¨ì¼ ê°’ì˜ íƒ€ì…ì„ ì¶”ë¡ í•©ë‹ˆë‹¤.
        
        Args:
            value: ë¶„ì„í•  ê°’
            context: ì¶”ë¡ ì„ ìœ„í•œ ì„ íƒì  ì»¨í…ìŠ¤íŠ¸
            
        Returns:
            íƒ€ì… ì¶”ë¡  ê²°ê³¼ (íƒ€ì…, ì‹ ë¢°ë„ í¬í•¨)
        """
        analysis = await self.infer_column_type(
            [value],
            column_name=context.get("column_name") if context else "single_value",
            include_complex_types=context.get("include_complex_types", True) if context else True,
            metadata=context,
        )
        return analysis.inferred_type

    async def _analyze_single_column(
        self, data: List[List[Any]], headers: List[str], include_complex_types: bool = False
    ) -> List[InterfaceColumnResult]:
        """
        ë‹¨ì¼ ì»¬ëŸ¼ ë¶„ì„ì„ ìœ„í•œ ë¹„ë™ê¸° í—¬í¼ ë©”ì„œë“œ
        """
        try:
            request_data = {
                "data": data,
                "columns": headers,
                "sample_size": len(data),
                "include_complex_types": include_complex_types,
            }

            response = await self.funnel_client.analyze_dataset(request_data)

            # Funnel ì‘ë‹µì„ Interface í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            return [self._convert_funnel_column_result(col) for col in response.get("columns", [])]

        except Exception as e:
            logger.error(f"Funnel ì„œë¹„ìŠ¤ ë¶„ì„ ì‹¤íŒ¨: {e}")
            # ê¸°ë³¸ê°’ ë°˜í™˜
            return []

    async def _analyze_dataset_async(
        self,
        data: List[List[Any]],
        headers: List[str],
        include_complex_types: bool = False,
        sample_size: Optional[int] = None,
    ) -> List[InterfaceColumnResult]:
        """
        ë°ì´í„°ì…‹ ë¶„ì„ì„ ìœ„í•œ ë¹„ë™ê¸° í—¬í¼ ë©”ì„œë“œ
        """
        try:
            request_data = {
                "data": data,
                "columns": headers,
                "sample_size": sample_size or 1000,
                "include_complex_types": include_complex_types,
            }

            response = await self.funnel_client.analyze_dataset(request_data)

            # Funnel ì‘ë‹µì„ Interface í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            return [self._convert_funnel_column_result(col) for col in response.get("columns", [])]

        except Exception as e:
            logger.error(f"Funnel ì„œë¹„ìŠ¤ ë¶„ì„ ì‹¤íŒ¨: {e}")
            # ê¸°ë³¸ê°’ ë°˜í™˜
            return []

    def _convert_funnel_column_result(self, funnel_result: Dict[str, Any]) -> InterfaceColumnResult:
        """
        Funnel ì„œë¹„ìŠ¤ ì‘ë‹µì„ Interface í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        """
        # Funnel ì‘ë‹µì€ shared.models.type_inference.ColumnAnalysisResultì™€ í˜¸í™˜ë˜ëŠ” í˜•íƒœë¥¼ ë°˜í™˜
        # (ìƒˆ í•„ë“œê°€ ì¶”ê°€ë˜ì–´ë„ Pydanticì´ ê¸°ë³¸ê°’/ignoreë¡œ ì²˜ë¦¬)
        inferred_type = funnel_result.get("inferred_type") or {}
        funnel_result["inferred_type"] = InterfaceTypeResult(
            type=inferred_type.get("type", "xsd:string"),
            confidence=inferred_type.get("confidence", 0.5),
            reason=inferred_type.get("reason", "No reason provided"),
            metadata=inferred_type.get("metadata"),
        )

        return InterfaceColumnResult(**funnel_result)

    async def close(self):
        """
        í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ
        """
        if self.funnel_client:
            await self.funnel_client.close()
