# 🔥 SPICE HARVESTER 백엔드 - 완전한 프론트엔드 개발 가이드

## 📋 목차

1. [시스템 아키텍처](#시스템-아키텍처)
2. [서비스 개요](#서비스-개요)
3. [복합 데이터 타입 시스템](#복합-데이터-타입-시스템)
4. [버전 제어 시스템](#버전-제어-시스템)
5. [보안 및 검증](#보안-및-검증)
6. [레이블 매핑 시스템](#레이블-매핑-시스템)
7. [병합 충돌 해결](#병합-충돌-해결)
8. [데이터베이스 관리](#데이터베이스-관리)
9. [쿼리 시스템](#쿼리-시스템)
10. [인증 및 권한 부여](#인증-및-권한-부여)
11. [에러 처리](#에러-처리)
12. [웹소켓 및 실시간 기능](#웹소켓-및-실시간-기능)
13. [테스트 및 개발](#테스트-및-개발)
14. [프로덕션 배포](#프로덕션-배포)

---

## 🏗️ 시스템 아키텍처

### 서비스 아키텍처
SPICE HARVESTER 백엔드는 **마이크로서비스 아키텍처**를 따르며 두 개의 주요 서비스로 구성됩니다:

1. **Backend-for-Frontend (BFF)** - 포트 8002
   - 사용자 대면 API 계층
   - 데이터 집계 및 변환
   - 레이블 매핑 및 다국어 지원
   - 병합 충돌 해결

2. **온톨로지 관리 서비스 (OMS)** - 포트 8000
   - 핵심 온톨로지 작업
   - TerminusDB 통합
   - 버전 제어 (Git과 유사)
   - 고급 관계 관리

### 기술 스택
- **FastAPI** - REST API 프레임워크
- **TerminusDB** - 온톨로지용 그래프 데이터베이스
- **httpx** - 비동기 HTTP 클라이언트
- **SQLite** - 레이블 매핑 영속성
- **Pydantic** - 데이터 검증
- **WebSocket** - 실시간 업데이트

---

## 🌐 서비스 개요

### 1. Backend-for-Frontend (BFF) 서비스
**기본 URL**: `http://localhost:8002`

#### 사용 가능한 엔드포인트:
- **온톨로지 관리**: `/api/v1/ontology/{db_name}/`
- **쿼리 시스템**: `/api/v1/query/{db_name}/`
- **레이블 매핑**: `/api/v1/database/{db_name}/mappings/`
- **병합 충돌**: `/api/v1/database/{db_name}/merge/`

### 2. 온톨로지 관리 서비스 (OMS)
**기본 URL**: `http://localhost:8000`

#### 사용 가능한 엔드포인트:
- **데이터베이스**: `/api/v1/database/`
- **온톨로지**: `/api/v1/ontology/{db_name}/`
- **버전 제어**: `/api/v1/version/{db_name}/`
- **브랜치 관리**: `/api/v1/branch/{db_name}/`

---

## 🔥 복합 데이터 타입 시스템

### 지원되는 데이터 타입

#### 기본 타입 (XSD):
```typescript
type BasicDataType = 
  | "xsd:string" | "xsd:integer" | "xsd:decimal" | "xsd:boolean"
  | "xsd:date" | "xsd:dateTime" | "xsd:time" | "xsd:duration"
  | "xsd:anyURI" | "xsd:base64Binary" | "xsd:hexBinary"
  | "xsd:normalizedString" | "xsd:token" | "xsd:language"
  | "xsd:double" | "xsd:float" | "xsd:long" | "xsd:int"
  | "xsd:short" | "xsd:byte" | "xsd:nonNegativeInteger"
  | "xsd:positiveInteger" | "xsd:nonPositiveInteger"
  | "xsd:negativeInteger" | "xsd:unsignedLong"
  | "xsd:unsignedInt" | "xsd:unsignedShort" | "xsd:unsignedByte"
  | "xsd:gYear" | "xsd:gMonth" | "xsd:gDay" | "xsd:gYearMonth"
  | "xsd:gMonthDay" | "xsd:QName" | "xsd:NOTATION";
```

#### 🔥 복합 타입 (사용자 정의):
```typescript
type ComplexDataType = 
  | "custom:array"      // 검증이 포함된 동적 배열
  | "custom:object"     // 스키마 검증이 포함된 중첩 객체
  | "custom:enum"       // 다국어 레이블이 포함된 열거형
  | "custom:money"      // 정밀도와 로케일이 포함된 통화
  | "custom:phone"      // 국제 전화번호 검증
  | "custom:email"      // 도메인 확인이 포함된 이메일 검증
  | "custom:coordinate" // 지리적 좌표 (위도/경도)
  | "custom:address"    // 구조화된 우편 주소
  | "custom:image"      // 검증이 포함된 이미지 메타데이터
  | "custom:file";      // 타입 확인이 포함된 파일 첨부
```

### 복합 타입 사용 예시

#### 1. 배열 타입
```typescript
// 요청 본문
{
  "id": "Product",
  "properties": {
    "tags": {
      "type": "custom:array",
      "constraints": {
        "items": {
          "type": "xsd:string",
          "maxLength": 50
        },
        "minItems": 1,
        "maxItems": 10,
        "uniqueItems": true
      }
    }
  }
}

// 유효한 데이터
{
  "tags": ["전자제품", "모바일", "스마트폰"]
}
```

#### 2. 객체 타입
```typescript
// 요청 본문
{
  "id": "Person",
  "properties": {
    "address": {
      "type": "custom:object",
      "constraints": {
        "properties": {
          "street": {"type": "xsd:string", "maxLength": 100},
          "city": {"type": "xsd:string", "maxLength": 50},
          "zipCode": {"type": "xsd:string", "pattern": "\\d{5}"}
        },
        "required": ["street", "city"]
      }
    }
  }
}

// 유효한 데이터
{
  "address": {
    "street": "서울시 강남구 테헤란로 123",
    "city": "서울",
    "zipCode": "12345"
  }
}
```

#### 3. 통화 타입
```typescript
// 요청 본문
{
  "id": "Product",
  "properties": {
    "price": {
      "type": "custom:money",
      "constraints": {
        "currency": "KRW",
        "precision": 2,
        "minimum": 0,
        "maximum": 10000000
      }
    }
  }
}

// 유효한 데이터
{
  "price": {
    "amount": 29900,
    "currency": "KRW"
  }
}
```

#### 4. 이메일 타입
```typescript
// 요청 본문
{
  "id": "User",
  "properties": {
    "email": {
      "type": "custom:email",
      "constraints": {
        "domains": ["company.com", "gmail.com"],
        "maxLength": 255
      }
    }
  }
}

// 유효한 데이터
{
  "email": "user@company.com"
}
```

#### 5. 좌표 타입
```typescript
// 요청 본문
{
  "id": "Location",
  "properties": {
    "position": {
      "type": "custom:coordinate",
      "constraints": {
        "crs": "EPSG:4326",
        "precision": 6
      }
    }
  }
}

// 유효한 데이터
{
  "position": {
    "latitude": 37.5665,
    "longitude": 126.9780
  }
}
```

---

## 🔀 버전 제어 시스템

### Git과 유사한 작업

#### 1. 브랜치 관리
```typescript
// 브랜치 목록 조회
GET /api/v1/branch/{db_name}/list

// 브랜치 생성
POST /api/v1/branch/{db_name}/create
{
  "branch_name": "feature/new-ontology",
  "from_branch": "main"
}

// 브랜치 삭제
DELETE /api/v1/branch/{db_name}/branch/{branch_name}?force=false

// 브랜치 체크아웃
POST /api/v1/branch/{db_name}/checkout
{
  "target": "develop",
  "target_type": "branch"
}
```

#### 2. 커밋 작업
```typescript
// 커밋 생성
POST /api/v1/version/{db_name}/commit
{
  "message": "새로운 제품 온톨로지 추가",
  "author": "admin"
}

// 커밋 히스토리 조회
GET /api/v1/version/{db_name}/history?branch=main&limit=10&offset=0

// 커밋 간 차이 조회
GET /api/v1/version/{db_name}/diff?from_ref=main&to_ref=feature/new-ontology
```

#### 3. 병합 작업
```typescript
// 브랜치 병합
POST /api/v1/version/{db_name}/merge
{
  "source_branch": "feature/new-ontology",
  "target_branch": "main",
  "strategy": "auto"
}

// 커밋으로 롤백
POST /api/v1/version/{db_name}/rollback
{
  "target": "HEAD~1"
}

// 브랜치 리베이스
POST /api/v1/version/{db_name}/rebase?onto=main&branch=feature/new-ontology
```

---

## 🔒 보안 및 검증

### 입력 정화
모든 사용자 입력은 포괄적인 `InputSanitizer` 클래스를 사용하여 자동으로 정화됩니다:

#### 탐지되는 보안 패턴:
- **SQL 인젝션**: `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `DROP`, `--`, `/*` 등
- **XSS**: `<script>`, `<iframe>`, `javascript:`, `eval()` 등
- **경로 조작**: `../`, `..\\`, URL 인코딩된 변형
- **명령 인젝션**: 셸 메타문자, 명령 패턴
- **NoSQL 인젝션**: `$where`, `$ne`, `$regex` 등
- **LDAP 인젝션**: 필터 패턴, 특수 문자

#### 요청 검증 미들웨어
```typescript
// 보안 설정
{
  "MAX_REQUEST_SIZE": 10 * 1024 * 1024, // 10MB
  "MAX_JSON_DEPTH": 10,
  "MAX_FIELD_LENGTH": 1000,
  "MAX_ARRAY_LENGTH": 1000,
  "MAX_REQUESTS_PER_MINUTE": 100,
  "MAX_REQUESTS_PER_HOUR": 1000
}

// 자동 보안 헤더
{
  "X-Content-Type-Options": "nosniff",
  "X-Frame-Options": "DENY",
  "X-XSS-Protection": "1; mode=block",
  "Referrer-Policy": "strict-origin-when-cross-origin"
}
```

### 인증 및 권한 부여
```typescript
// 데이터베이스 이름 검증
function validateDbName(name: string): boolean {
  return /^[a-zA-Z][a-zA-Z0-9_-]*$/.test(name);
}

// 브랜치 이름 검증
function validateBranchName(name: string): boolean {
  return /^[a-zA-Z0-9_/-]+$/.test(name);
}

// 클래스 ID 검증
function validateClassId(id: string): boolean {
  return /^[a-zA-Z][a-zA-Z0-9_:-]*$/.test(id);
}
```

---

## 🏷️ 레이블 매핑 시스템

### 다국어 지원
시스템은 국제화를 위한 포괄적인 레이블 매핑을 지원합니다:

#### 1. 매핑 내보내기
```typescript
// 모든 매핑 내보내기
GET /api/v1/database/{db_name}/mappings/export

// 응답
{
  "db_name": "product_ontology",
  "classes": [
    {
      "class_id": "Product",
      "label": "제품",
      "label_lang": "ko",
      "description": "제품 정보"
    }
  ],
  "properties": [
    {
      "property_id": "name",
      "label": "이름",
      "label_lang": "ko"
    }
  ],
  "relationships": [
    {
      "predicate": "hasCategory",
      "label": "카테고리",
      "label_lang": "ko"
    }
  ]
}
```

#### 2. 매핑 가져오기
```typescript
// 파일 업로드로 가져오기
POST /api/v1/database/{db_name}/mappings/import
Content-Type: multipart/form-data

// 보안 기능:
// - 파일 크기 제한: 10MB
// - 컨텐츠 타입 검증
// - 스키마 검증
// - 무결성 검사 (SHA256)
// - 실패 시 롤백
```

#### 3. 매핑 통계
```typescript
// 매핑 요약 조회
GET /api/v1/database/{db_name}/mappings/

// 응답
{
  "database": "product_ontology",
  "total": {
    "classes": 25,
    "properties": 150,
    "relationships": 45
  },
  "by_language": {
    "ko": {"classes": 25, "properties": 150, "relationships": 45},
    "en": {"classes": 25, "properties": 150, "relationships": 45},
    "ja": {"classes": 12, "properties": 80, "relationships": 20}
  }
}
```

---

## ⚔️ 병합 충돌 해결

### Foundry 스타일 충돌 해결

#### 1. 병합 시뮬레이션
```typescript
// 충돌 감지를 위한 병합 시뮬레이션
POST /api/v1/database/{db_name}/merge/simulate
{
  "source_branch": "feature/new-ontology",
  "target_branch": "main",
  "strategy": "merge"
}

// 응답
{
  "status": "success",
  "message": "병합 시뮬레이션 완료: 3개 충돌 감지",
  "data": {
    "merge_preview": {
      "source_branch": "feature/new-ontology",
      "target_branch": "main",
      "conflicts": [
        {
          "path": "Product.name",
          "type": "content_conflict",
          "source_change": {
            "type": "modified",
            "new_value": "제품명 v2",
            "old_value": "제품명"
          },
          "target_change": {
            "type": "modified",
            "new_value": "제품 제목",
            "old_value": "제품명"
          }
        }
      ],
      "statistics": {
        "changes_to_apply": 15,
        "conflicts_detected": 3,
        "mergeable": false,
        "requires_manual_resolution": true
      }
    }
  }
}
```

#### 2. 충돌 해결
```typescript
// 수동 충돌 해결
POST /api/v1/database/{db_name}/merge/resolve
{
  "source_branch": "feature/new-ontology",
  "target_branch": "main",
  "strategy": "merge",
  "message": "충돌 해결: 제품명 업데이트",
  "author": "admin@company.com",
  "resolutions": [
    {
      "path": "Product.name",
      "resolution_type": "use_value",
      "resolved_value": "제품 제목 v2",
      "metadata": {
        "reason": "두 변경사항 결합"
      }
    }
  ]
}
```

---

## 🗄️ 데이터베이스 관리

### 데이터베이스 작업

#### 1. 데이터베이스 생성
```typescript
POST /api/v1/database/create
{
  "name": "product_ontology",
  "description": "제품 카탈로그 온톨로지"
}
```

#### 2. 데이터베이스 목록 조회
```typescript
GET /api/v1/database/list

// 응답
{
  "databases": [
    {
      "name": "product_ontology",
      "description": "제품 카탈로그 온톨로지",
      "created_at": "2024-01-01T00:00:00Z",
      "size": "15.2MB",
      "status": "active"
    }
  ]
}
```

#### 3. 데이터베이스 상태
```typescript
GET /api/v1/database/exists/{db_name}

// 응답
{
  "exists": true,
  "name": "product_ontology",
  "status": "active",
  "branches": ["main", "develop"],
  "current_branch": "main"
}
```

---

## 🔍 쿼리 시스템

### 구조화된 쿼리 인터페이스

#### 1. 기본 쿼리
```typescript
POST /api/v1/query/{db_name}/execute
{
  "type": "select",
  "class_id": "Product",
  "filters": [
    {
      "property": "category",
      "operator": "eq",
      "value": "electronics"
    }
  ],
  "limit": 10,
  "offset": 0
}
```

#### 2. 관계를 포함한 복합 쿼리
```typescript
POST /api/v1/query/{db_name}/execute
{
  "type": "select",
  "class_id": "Product",
  "filters": [
    {
      "property": "price",
      "operator": "gte",
      "value": {
        "amount": 100000,
        "currency": "KRW"
      }
    }
  ],
  "relationships": [
    {
      "predicate": "hasCategory",
      "target_class": "Category",
      "direction": "outgoing"
    }
  ],
  "include_labels": true,
  "language": "ko"
}
```

#### 3. 집계 쿼리
```typescript
POST /api/v1/query/{db_name}/execute
{
  "type": "count",
  "class_id": "Product",
  "filters": [
    {
      "property": "status",
      "operator": "eq",
      "value": "active"
    }
  ],
  "group_by": ["category"]
}
```

---

## 🔄 관계 관리

### 고급 관계 기능

#### 1. 순환 참조 탐지
```typescript
// 온톨로지 생성 중 자동 탐지
POST /api/v1/ontology/{db_name}/create
{
  "id": "Category",
  "relationships": [
    {
      "predicate": "hasParent",
      "target_class": "Category",
      "cardinality": "many_to_one"
    }
  ]
}

// 시스템이 순환 참조를 자동으로 탐지하고 방지
```

#### 2. 관계 경로 추적
```typescript
// 엔티티 간 경로 찾기
GET /api/v1/ontology/{db_name}/path?from=Product&to=Brand

// 응답
{
  "paths": [
    {
      "length": 2,
      "relationships": [
        {"predicate": "hasCategory", "target": "Category"},
        {"predicate": "hasBrand", "target": "Brand"}
      ]
    }
  ]
}
```

#### 3. 관계 검증
```typescript
// 심각도 수준이 포함된 검증 결과
{
  "validation_results": [
    {
      "severity": "error",
      "message": "순환 참조 감지",
      "path": "Product -> Category -> Product"
    },
    {
      "severity": "warning",
      "message": "깊은 관계 중첩 (5레벨 초과)",
      "path": "Product -> Category -> SubCategory -> ..."
    }
  ]
}
```

---

## 🌐 웹소켓 및 실시간 기능

### 실시간 업데이트
```typescript
// 실시간 업데이트를 위한 WebSocket 연결
const ws = new WebSocket('ws://localhost:8000/ws/updates/{db_name}');

// 메시지 타입
interface UpdateMessage {
  type: 'ontology_created' | 'ontology_updated' | 'ontology_deleted' | 'merge_completed';
  data: {
    entity_id: string;
    database: string;
    timestamp: string;
    changes: any;
  };
}

// 특정 이벤트 구독
ws.send(JSON.stringify({
  action: 'subscribe',
  events: ['ontology_created', 'merge_completed']
}));
```

---

## 📊 에러 처리

### 표준화된 에러 응답

#### 1. 검증 오류
```typescript
// HTTP 400 - 잘못된 요청
{
  "status": "error",
  "message": "검증 실패",
  "detail": "이메일 형식이 올바르지 않습니다",
  "code": "VALIDATION_ERROR",
  "field": "email"
}
```

#### 2. 보안 위반
```typescript
// HTTP 400 - 잘못된 요청
{
  "status": "error",
  "message": "보안 위반 감지",
  "detail": "SQL 인젝션 패턴 감지",
  "code": "SECURITY_VIOLATION"
}
```

#### 3. 충돌 오류
```typescript
// HTTP 409 - 충돌
{
  "status": "error",
  "message": "병합 충돌 감지",
  "detail": "수동 해결 필요",
  "code": "MERGE_CONFLICT",
  "conflicts": [...]
}
```

#### 4. 찾을 수 없음 오류
```typescript
// HTTP 404 - 찾을 수 없음
{
  "status": "error",
  "message": "리소스를 찾을 수 없음",
  "detail": "데이터베이스 'test_db'가 존재하지 않습니다",
  "code": "NOT_FOUND"
}
```

---

## 🧪 테스트 및 개발

### 개발 환경 설정

#### 1. 서비스 시작
```bash
# 모든 서비스 시작
cd /Users/isihyeon/Desktop/SPICE\ HARVESTER/backend
./start_services.sh

# 서비스 접속 주소:
# - BFF: http://localhost:8002
# - OMS: http://localhost:8000
# - TerminusDB: http://localhost:6363
```

#### 2. 헬스 체크
```typescript
// 서비스 상태 확인
GET http://localhost:8002/health  // BFF
GET http://localhost:8000/health  // OMS

// 예상 응답
{
  "status": "healthy",
  "timestamp": "2024-01-01T00:00:00Z",
  "services": {
    "database": "connected",
    "terminus": "connected"
  }
}
```

#### 3. 복합 타입 테스트
```typescript
// 복합 타입 검증 테스트
POST http://localhost:8002/api/v1/ontology/test_db/create
{
  "id": "TestClass",
  "properties": {
    "email": {
      "type": "custom:email",
      "constraints": {
        "domains": ["test.com"]
      }
    }
  }
}
```

---

## 🚀 프로덕션 배포

### 프로덕션 고려사항

#### 1. 환경 변수
```bash
# 필수 환경 변수
TERMINUS_DB_URL=http://terminusdb:6363
TERMINUS_DB_USER=admin
TERMINUS_DB_PASSWORD=password
BFF_PORT=8002
OMS_PORT=8000
DATABASE_PATH=/data/label_mappings.db
LOG_LEVEL=INFO
```

#### 2. 보안 설정
```typescript
// 프로덕션 보안 설정
{
  "ALLOWED_ORIGINS": ["https://yourapp.com"],
  "RATE_LIMIT_ENABLED": true,
  "CORS_CREDENTIALS": true,
  "HTTPS_ONLY": true,
  "CSRF_PROTECTION": true
}
```

#### 3. 모니터링 및 로깅
```typescript
// 구조화된 로깅 형식
{
  "timestamp": "2024-01-01T00:00:00Z",
  "level": "INFO",
  "service": "BFF",
  "message": "온톨로지 생성됨",
  "context": {
    "database": "product_ontology",
    "class_id": "Product",
    "user": "admin"
  }
}
```

---

## 📱 프론트엔드 통합 예시

### React 통합

#### 1. API 클라이언트 설정
```typescript
// api/client.ts
class SpiceHarvesterClient {
  private bffUrl = 'http://localhost:8002';
  private omsUrl = 'http://localhost:8000';
  
  async createOntology(dbName: string, ontologyData: any) {
    const response = await fetch(`${this.bffUrl}/api/v1/ontology/${dbName}/create`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(ontologyData),
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  async queryOntologies(dbName: string, queryData: any) {
    const response = await fetch(`${this.bffUrl}/api/v1/query/${dbName}/execute`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(queryData),
    });
    
    return response.json();
  }
}
```

#### 2. 복합 타입 폼 컴포넌트
```typescript
// components/ComplexTypeForm.tsx
import React, { useState } from 'react';

interface ComplexTypeFormProps {
  onSubmit: (data: any) => void;
}

const ComplexTypeForm: React.FC<ComplexTypeFormProps> = ({ onSubmit }) => {
  const [formData, setFormData] = useState({
    id: '',
    properties: {}
  });
  
  const handleAddProperty = (name: string, type: string, constraints: any) => {
    setFormData(prev => ({
      ...prev,
      properties: {
        ...prev.properties,
        [name]: {
          type,
          constraints
        }
      }
    }));
  };
  
  return (
    <form onSubmit={(e) => { e.preventDefault(); onSubmit(formData); }}>
      {/* 이메일 속성 */}
      <div>
        <label>이메일 속성:</label>
        <input 
          type="text" 
          placeholder="속성 이름"
          onChange={(e) => handleAddProperty(e.target.value, 'custom:email', {
            domains: ['company.com'],
            maxLength: 255
          })}
        />
      </div>
      
      {/* 통화 속성 */}
      <div>
        <label>통화 속성:</label>
        <input 
          type="text" 
          placeholder="속성 이름"
          onChange={(e) => handleAddProperty(e.target.value, 'custom:money', {
            currency: 'KRW',
            precision: 2,
            minimum: 0
          })}
        />
      </div>
      
      <button type="submit">온톨로지 생성</button>
    </form>
  );
};
```

#### 3. 버전 제어 컴포넌트
```typescript
// components/VersionControl.tsx
import React, { useState, useEffect } from 'react';

const VersionControl: React.FC<{ dbName: string }> = ({ dbName }) => {
  const [branches, setBranches] = useState([]);
  const [currentBranch, setCurrentBranch] = useState('');
  
  useEffect(() => {
    fetchBranches();
  }, [dbName]);
  
  const fetchBranches = async () => {
    const response = await fetch(`http://localhost:8000/api/v1/branch/${dbName}/list`);
    const data = await response.json();
    setBranches(data.branches);
    setCurrentBranch(data.current);
  };
  
  const createBranch = async (branchName: string) => {
    await fetch(`http://localhost:8000/api/v1/branch/${dbName}/create`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        branch_name: branchName,
        from_branch: currentBranch
      })
    });
    fetchBranches();
  };
  
  const checkout = async (branchName: string) => {
    await fetch(`http://localhost:8000/api/v1/branch/${dbName}/checkout`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        target: branchName,
        target_type: 'branch'
      })
    });
    fetchBranches();
  };
  
  return (
    <div>
      <h3>버전 제어</h3>
      <p>현재 브랜치: <strong>{currentBranch}</strong></p>
      
      <div>
        <h4>브랜치 목록:</h4>
        <ul>
          {branches.map((branch: any) => (
            <li key={branch.name}>
              {branch.name} 
              {branch.current && <span> (현재)</span>}
              {!branch.current && (
                <button onClick={() => checkout(branch.name)}>
                  체크아웃
                </button>
              )}
            </li>
          ))}
        </ul>
      </div>
      
      <div>
        <input 
          type="text" 
          placeholder="새 브랜치 이름"
          onKeyPress={(e) => {
            if (e.key === 'Enter') {
              createBranch(e.target.value);
              e.target.value = '';
            }
          }}
        />
      </div>
    </div>
  );
};
```

---

## 🎯 모범 사례 및 권장사항

### 1. 데이터 검증
- 프론트엔드에서 항상 복합 타입 제약조건을 검증하세요
- Pydantic 모델과 일치하는 TypeScript 인터페이스를 사용하세요
- 더 나은 UX를 위해 클라이언트 측 검증을 구현하세요

### 2. 에러 처리
- 네트워크 실패에 대한 재시도 로직을 구현하세요
- 사용자 친화적인 에러 메시지를 표시하세요
- 디버깅을 위해 에러를 로깅하세요

### 3. 성능 최적화
- 대용량 데이터셋에는 페이지네이션을 사용하세요
- 자주 접근하는 데이터에 대한 캐싱을 구현하세요
- 실시간 업데이트에는 WebSocket 사용을 고려하세요

### 4. 보안
- 모든 사용자 입력을 정화하세요
- 파일 업로드(크기, 타입, 내용)를 검증하세요
- 프로덕션에서는 HTTPS를 사용하세요

### 5. 국제화
- 레이블 매핑 시스템을 활용하세요
- 다국어를 지원하세요
- 로케일별 형식을 사용하세요

---

이 포괄적인 가이드는 SPICE HARVESTER 백엔드에서 구현된 모든 기능을 다룹니다. 복합 타입 시스템, 버전 제어, 보안 기능 및 사용 가능한 모든 서비스와 통합하여 프론트엔드 개발을 위한 완전한 참조 자료로 활용하세요.

추가 질문이나 기능이 필요하시면 특정 엔드포인트 문서를 참조하거나 개발팀에 문의하세요.

**🔥 Think Ultra! 이 가이드는 SPICE HARVESTER 백엔드의 완전한 구현을 나타냅니다 - 모든 기능, 모든 엔드포인트, 모든 기능이 프론트엔드 개발 요구사항에 맞게 문서화되었습니다.**