**Palantir Foundry Ontology Editor** (일명 Ontology Manager, 온톨로지 관리 애플리케이션)는 Palantir Foundry 플랫폼에서 기업의 데이터 **온톨로지(Ontology)**를 구축하고 관리하기 위한 전문 UI 도구입니다 . 온톨로지는 조직의 디지털 자산(데이터셋, 모델 등)을 현실 세계의 개념(예: 설비, 제품, 주문, 거래 등)에 연결한 *“디지털 트윈”* 개념의 **코어 데이터 모델**로서, 오브젝트(엔터티), 속성, 링크(관계) 등의 **시멘틱 요소**와 액션, 함수 등의 **키네틱 요소**를 포함합니다  . Ontology Editor를 통해 사용자는 이러한 온톨로지 구성요소들을 **코드 작성 없이** 시각적 인터페이스로 정의하고, 데이터 원본에 매핑하며, 상호 관계를 설정함으로써 조직 전반의 **공통 데이터 언어**를 형성할 수 있습니다  .

## **Ontology Editor의 주요 UI 화면과 구성 요소**

Ontology Editor는 Foundry 워크스페이스 내 독립된 애플리케이션으로, 여러 **주요 화면(view)**과 UI 패널로 구성되어 있습니다 . 상단 네비게이션 바와 좌측 사이드바가 모든 화면에 공통으로 표시되며, 이를 통해 온톨로지 리소스 간 **일관된 내비게이션**이 가능합니다. 아래에서는 Ontology Editor의 핵심 화면과 UI 컴포넌트들을 살펴봅니다.

### **네비게이션: 상단 바와 사이드바**

상단 바(Top bar)와 사이드바(Sidebar)는 Ontology Editor 전 영역에서 지속적으로 표시되는 주요 내비게이션 요소입니다 . **상단 바**에서는 온톨로지 리소스 검색, 새 리소스 생성, 브랜치 전환/생성의 세 가지 기능을 제공합니다 . 예를 들어, 상단 바 우측의 **검색창**을 통해 객체 이름, 별칭(alias), RID 등으로 신속히 온톨로지 항목을 찾아볼 수 있으며(단축키 Cmd/Ctrl + K 지원), **“New” 버튼**을 눌러 새 Object Type, Link Type, Action Type 등을 생성할 수 있습니다 . 또한 상단 바에는 현재 편집 중인 **온톨로지 브랜치**를 표시하고 브랜치를 전환하거나 생성하는 드롭다운 메뉴가 있어, 온톨로지 변경 작업을 분기별로 관리할 수 있습니다 . 한편, **좌측 사이드바**는 Ontology Editor 내 다양한 리소스와 페이지로 이동할 수 있는 메뉴를 제공합니다 . 사이드바 최상단에는 편집 중인 온톨로지의 이름과 브랜치가 표시되며, 그 아래로 **Discover**, **Proposals**, **History**와 같은 관리 화면과 **Object Types (객체 유형)**, **Properties (속성)**, **Shared Properties (공유 속성)**, **Link Types (링크 유형)**, **Action Types (액션 유형)**, **Groups (그룹)**, **Interfaces (인터페이스)**, **Value Types (값 유형)**, **Functions (함수)** 등이 **리소스별 섹션**으로 나열됩니다  . 사용자는 사이드바를 통해 원하는 리소스 목록이나 특정 설정 페이지로 손쉽게 접근할 수 있으며, 현재 화면에 따라 사이드바 메뉴에 **활성 상태 강조표시**가 나타나 일관된 위치 인지와 내비게이션이 가능합니다.

### **Discover 화면 (온톨로지 홈 대시보드)**

Ontology Editor를 열면 가장 먼저 **Discover 화면**(둘러보기 화면)이 기본 홈으로 표시됩니다 . Discover 뷰는 사용자가 자주 다루는 온톨로지 항목들을 한눈에 볼 수 있도록 **개인화된 대시보드** 형태로 구성되어 있습니다 . 기본 설정에서 Discover 화면에는 **즐겨찾는 오브젝트 타입**, **최근에 본 오브젝트 타입**, **즐겨찾는 그룹** 섹션이 카드 형태로 나타나며, 각 섹션당 항목 리스트가 표시됩니다 . 예를 들어 사용자가 특정 Object Type을 즐겨찾기로 지정하면 “Favorite object types” 영역에 해당 객체가 표시되고, 최근 열람한 객체들은 “Recently viewed” 영역에 자동 나열됩니다 . **신규 사용자**의 경우에는 즐겨찾기나 최근 항목이 없으므로, 대신 **온톨로지에 최근 수정된 모든 Object Type** 목록이나 **주요 Object Type 전체 목록** 등의 기본 섹션이 제공되어 초기 탐색을 도와줍니다 . 또한 Discover 화면은 **구성(customize)** 기능을 제공하여, 사용자별로 어떤 섹션들을 볼지 및 각 섹션당 표시할 항목 수를 자유롭게 조정할 수 있습니다 . 예컨대 “홈 화면 설정” 옵션에서 “최근 본 객체”, “즐겨찾는 객체”, 특정 그룹의 객체 목록 등을 추가/제거하거나 정렬할 수 있으며 , UI는 이러한 설정을 기억하여 **사용자 맞춤형 홈 화면**을 구성합니다. 이를 통해 Ontology Editor 접속 시 바로 중요한 자산들에 접근할 수 있어 사용자 편의성이 높아집니다.

### **Object Type 상세 화면 (객체 타입 뷰)**

Ontology Editor의 핵심 기능 중 하나는 **Object Type**(오브젝트 유형) 관리이며, 사이드바나 Discover 화면 등에서 특정 Object Type을 선택하면 해당 **Object Type 상세 화면(view)**이 열립니다 . Object Type 화면은 왼쪽의 **세부 페이지 메뉴**와 오른쪽의 **콘텐츠 영역**으로 나뉜 2열 레이아웃으로 구성됩니다 . 좌측 메뉴에는 선택된 Object Type과 관련된 서브 페이지들(Overview, Properties, Security, Datasources 등)이 표시되고, 우측에는 해당 페이지의 상세 내용이 나타납니다 . 기본으로 열리는 **Overview 페이지**에는 해당 Object Type의 전반적인 요약 정보가 카드 섹션 형태로 정리되어 있습니다 . Overview 화면 구성 요소를 예로 들면 다음과 같습니다 :

*Ontology Editor의 Object Type Overview 화면 예시.*  Overview 탭에는 (1) **Object Type 메타데이터**(Display Name, Description, ID, 그룹, 아이콘 등) 영역, (2) **Properties 목록**(정의된 속성들의 리스트), (3) **Action Types** (이 Object Type에 연결된 액션 정의 목록), (4) **Link Type Graph** (해당 객체와 다른 객체 간 관계를 시각화한 링크 그래프), (5) **Dependents** (이 Object Type을 참조하는 다른 리소스나 애플리케이션 목록), (6) **Data** (백킹 데이터소스 정보 및 데이터 상태), (7) **Usage** (이 Object Type이 사용되는 곳이나 사용 빈도 통계) 섹션이 표시됩니다  . 예컨대 Object Type 메타데이터 영역에서는 Display Name/Plural Name, Description, 고유 ID, 소속 Group, 아이콘 및 색상 등을 확인 및 편집할 수 있고  , Properties 섹션에는 속성 이름과 타입, 키 지정 여부, 가시성 등의 속성 목록이 표 형태로 나열됩니다. 또한 Link Type Graph 섹션에서는 현재 Object Type이 맺고 있는 **다른 Object Type과의 관계를 그래프로 시각화**하여 보여주며, 노드를 클릭하면 해당 링크의 상세정보를 볼 수 있는 **Link Type 화면**으로 진입할 수 있습니다 . 이러한 Overview 화면은 한 화면에서 해당 객체 타입의 구조와 연결 정보를 조망할 수 있게 해주며, 각 섹션의 항목을 클릭하면 관련 상세 편집 화면으로 **드릴다운**할 수 있는 **허브** 역할을 합니다.

오브젝트 유형 화면의 좌측 사이드바 메뉴를 통해 Overview 외에도 **Properties**, **Security**, **Datasources**, **Transforms**, **Workflow** 등의 탭으로 전환할 수 있습니다 (팔란티어 Foundry 버전과 설정에 따라 다소 차이가 있을 수 있음). 예를 들어 **Properties 탭**을 선택하면 해당 Object Type의 속성들을 관리하는 전용 화면으로 이동하며, **Security 탭**에서는 객체 수준의 권한과 접근제어 설정을, **Datasources 탭**에서는 이 Object Type의 백킹(backing) 데이터셋 현황과 빌드 상태 등을 확인할 수 있습니다. 이러한 탭 구성으로 하나의 Object Type에 대한 다양한 설정과 정보를 **맥락(context)** 전환 없이 한 곳에서 편집할 수 있습니다.

### **Property Editor 화면 (속성 편집기)**

어떤 Object Type의 Overview 페이지에서 속성(Property)을 하나 선택하면 **Property Editor 화면**이 오버레이 형태로 열리면서 해당 속성의 상세 설정을 편집할 수 있습니다 . Property Editor는 우측에 **속성 상세 패널**이, 좌측에 해당 Object Type의 **속성 리스트 패널**이 함께 나타나도록 구성되어 있어, 다른 속성으로의 빠른 전환과 비교가 용이합니다  .

*Ontology Editor의 Property Editor 화면.*  예를 들어 **Aircraft** 객체 타입에 대한 Property Editor를 보면, 왼쪽에는 이 Object Type에 정의된 모든 속성들의 목록과 각 속성의 상태(예: *Experimental* 상태, Primary Key/Title Key 여부, 표시 여부 등)가 표로 나열되어 있고, 오른쪽에는 선택한 특정 속성 (예: *Tail Number*)의 세부 설정 탭들이 표시됩니다. 속성 상세 패널은 **General(일반)**, **Display(표시)**, **Formatting(포맷)**, **Validation(검증)** 등 여러 탭으로 이루어져 각종 메타데이터를 편집할 수 있습니다  .

General 탭에서는 속성의 **Display Name(표시 이름)**과 **Description(설명)**을 바로 편집할 수 있고, **Status(상태)**를 *Active(활성)* / *Experimental(실험)* / *Deprecated(사용 중단)* 중 선택하여 속성의 성숙도 상태를 지정할 수 있습니다 . Status에 따라 편집 가능 여부가 달라지는데, 예를 들어 *Active* 상태의 속성은 API Name 수정이나 Primary Key 재지정이 불가하며(*Active* 속성의 API 이름은 변경 불가)  , *Deprecated* 속성은 새로운 애플리케이션에서 사용하지 말 것을 권고하는 의미로 UI에 표시됩니다. 또한 General 탭에서 해당 속성이 **Title Key**인지 **Primary Key**인지 키 역할을 지정할 수 있으며(한 Object Type당 하나의 Primary Key 필수)  , **API Name**(프로그래밍 호출용 식별자)을 설정하거나 변경할 수 있습니다. **Visibility(가시성)** 설정도 제공되어 속성을 *prominent(두드러지게 표시)* 혹은 *hidden(숨김)*으로 지정할 수 있는데, prominent로 지정된 속성은 Object Explorer나 워크샵 애플리케이션 등에서 **우선 노출**되고 hidden으로 설정된 속성은 기본 UI에 표시되지 않습니다  .

Display/Formatting 관련 탭에서는 **Value Formatting**(날짜나 수치 등의 표시 형식 지정)이나 **Conditional Formatting**(값에 따라 다른 스타일 적용)을 설정하여, 해당 속성이 사용될 때의 표시 형식을 사용자 정의할 수 있습니다  . 예컨대 통화 금액 속성에 통화 기호를 붙인다든지, 특정 범위 값에 대해 색상 강조를 한다든지 하는 규칙을 설정할 수 있습니다. **Property base type**도 편집 가능한데, 이는 해당 속성의 데이터 타입(정수, 문자열, 날짜, Boolean 등 기본 타입)을 의미하며, 잘못된 타입으로 변경 시 UI에서 오류를 표시하여 사용자가 즉시 인지할 수 있습니다 (예: 백킹 컬럼 타입과 호환되지 않는 속성 타입으로 변경하면 **에러 메시지**가 발생) . 이러한 검증을 통해 데이터 모델의 정합성을 유지합니다.

또한 Property Editor 상단에는 **백킹 데이터소스 매핑(Backing Datasource Mapping)** 기능이 있어, 해당 속성이 어떤 데이터셋의 어느 컬럼과 연결되는지 관리합니다. 화면 하단에 연결된 데이터 미预览(프리뷰)가 제공되어, 선택한 속성의 각 객체별 실제 값을 표 형태로 확인할 수 있습니다. 만약 속성을 데이터 컬럼과 연결(맵핑)하지 않으면 UI에 **Unmapped** 상태로 표시되며, 사용자는 Property Editor 내에서 **“Map to a column”** 옵션을 통해 새로운 데이터 컬럼에 연결할 수 있습니다 . 이미 맵핑된 경우 **“Unlink property”**를 통해 연결을 해제하거나 다른 컬럼으로 변경할 수도 있습니다 .

Ontology Editor는 **다중 속성 일괄 편집** 기능도 지원합니다. Property Editor에서 여러 속성을 Ctrl/Cmd로 선택하면 한꺼번에 Base Type, Visibility, Formatting 등을 변경할 수 있는 **Bulk Edit** 도구 모음이 나타나 효율적인 편집이 가능합니다  . 또한 Properties 탭(속성 목록 화면)에서도 체크박스로 여러 속성을 선택해 일괄 편집을 수행할 수 있어, 대규모 스키마 변경 시 편리함을 제공합니다 .

### **Link Type 화면 (관계 링크 화면)**

Ontology Editor를 통해 **객체 간 관계(Link Type)**도 시각적으로 정의하고 관리할 수 있습니다. Object Type Overview의 Link Type Graph에서 특정 링크를 클릭하거나, 사이드바의 Link Types 목록에서 링크를 선택하면 **Link Type 상세 화면**이 열립니다 . 링크 타입 화면은 해당 관계의 개요와 구성 정보를 보여주는 **Overview 탭**과, 백킹 데이터소스 등을 설정하는 **Datasources 탭**으로 구성됩니다 .

*Ontology Editor의 Link Type 상세 화면 (Foreign Key 방식 링크 예시).*  예를 들어 **Aircraft ↔ Airline** 간의 링크 타입을 보면, Overview 탭에 이 링크의 **Join Method** (Foreign Key, Dataset, Object Type 중 어떤 방식으로 연결되었는지)와 **양측 객체 타입**이 명시되어 있습니다. 또한 **Link Name**(표시용 관계명)과 **Link API Name**(코드 참조용 이름)이 각 방향별로 설정되어 있으며, 한쪽 객체에서 이 링크를 통해 상대 객체를 참조할 때 표시될 관계 명칭을 정의합니다  . 예를 들어 Flight → Aircraft 방향의 링크에 “Assigned Aircraft”라는 Display Name을 설정하면, Flight 객체에서 연결된 Aircraft를 볼 때 “Assigned Aircraft”라는 관계로 나타납니다  . API Name은 소문자 단어로 자동 생성되며 필요시 수정 가능하고, 온톨로지 내 고유해야 합니다 .

Link Type의 Datasources 탭에서는 **Foreign Key 링크**의 경우 양쪽 객체의 키 속성 매핑을, **Dataset 링크**의 경우 조인 테이블로 사용되는 백킹 데이터셋과 키 컬럼 매핑을 설정합니다  . 위 이미지 예시는 *Foreign Key* 방식으로 Aircraft 객체의 Primary Key (*Tail Number*)와 Flight 객체의 외래키 속성 (*Flight Tail Number*)을 연결한 경우인데, 이처럼 UI에서 드롭다운으로 각 객체의 속성을 선택하여 서로 연결되는 키를 지정할 수 있습니다  . 만약 *Many-to-Many* 관계라면, **Dataset 방식**을 택하여 별도의 조인 테이블을 지정하고 그 안의 두 컬럼을 각 객체의 Primary Key에 맵핑합니다  . Ontology Editor는 join table이 없을 경우 **자동 생성**하는 옵션도 제공하여, 사용자 편집 기반의 링크 데이터를 위한 빈 조인 테이블을 즉석에서 만들어줄 수 있습니다 . 또한 *Object-backed* 링크의 경우, 미리 정의된 중간 Object Type을 선택하여 양쪽을 연결하는 고급 구성도 UI로 설정 가능합니다  . Link Type 화면에서도 객체 타입 화면과 유사하게 상단바를 통해 아이콘/이름/ID 등의 메타데이터를 편집할 수 있으며, 링크 자체의 권한이나 속성(메타데이터용 속성을 링크에 부여하는 기능)도 설정할 수 있습니다.

### **Action Type 및 Function 화면 (액션/함수 편집)**

Ontology Editor는 **Action Types**(사용자 동작 정의)과 **Functions**(비즈니스 로직 함수)도 관리합니다. Object Type Overview의 Action Types 섹션에서 특정 액션을 클릭하면 **Action Type 화면**이 열리며, 액션의 **Overview 탭**과 **Logic(로직)** 탭 등이 표시됩니다 . Overview 탭에는 액션의 이름, 설명, 대상 객체, 파라미터 등의 요약정보가 나오고, Logic 탭에서는 해당 액션이 수행할 함수나 규칙을 설정합니다 . 예를 들어 “Aircraft를 마모 상태로 표시”와 같은 액션을 정의했다면, Logic 탭에서 어떤 함수를 호출해 객체 속성을 변경할지 연결합니다. Function 항목을 선택하면 **Function Type 화면**이 열리는데, 여기서는 함수의 버전 관리와 사용 이력을 중점적으로 보여줍니다 . 함수 화면의 **Usage History 패널**에서는 해당 함수의 버전별로 어떤 애플리케이션이나 액션에서 사용되었는지 목록이 나타나고, 필요시 클릭하여 해당 앱에서 함수 버전을 업그레이드하도록 이동할 수 있습니다 . 또한 함수 코드 편집이 필요한 경우 화면 우측 상단에 **“Open in Code Repository”** 버튼이 제공되어, Foundry의 내장 코드 레포지토리로 바로 이동해 함수를 수정할 수 있게 되어 있습니다 . 이처럼 Ontology Editor는 시멘틱 모델링에 국한되지 않고 **운영상의 동작과 로직 정의**까지 일관된 UI에서 다룰 수 있게 해줍니다.

### **변경 관리: Proposals 및 History**

Ontology Editor의 또 다른 중요한 화면으로 **Proposals(제안)** 뷰와 **History(히스토리)** 뷰가 있습니다. Foundry Ontology에서는 모든 스키마 변경이 곧바로 메인 온톨로지에 적용되지 않고, **브랜치 기반의 제안**으로 관리됩니다 . 상단 바에서 새 브랜치를 만들거나 기존 브랜치를 체크아웃한 후 수행한 변경 작업(예: 새로운 Object Type 생성, 속성 수정 등)은 **저장(commit)**하기 전까지 해당 브랜치의 *Proposed Changes*로 남습니다  . **Proposals 화면**에서는 이렇게 브랜치에 대기 중인 변경 사항들의 목록과 세부내용을 확인할 수 있고, 변경 내역에 대한 **검토 및 승인을 위한 워크플로우**가 이루어집니다 . 여러 사용자들이 협업하는 경우, 하나의 제안에 대해 승인자들이 코멘트를 남기거나 변경을 승인/거절할 수 있으며, 최종적으로 제안이 승인되면 메인 온톨로지에 병합(Merge)되어 실제로 스키마가 업데이트됩니다. 이러한 프로세스를 통해 온톨로지 변경사항을 **배포 전 검증**하고 거버넌스를 유지할 수 있습니다 .

**History 화면**에서는 온톨로지의 과거 변경 이력을 시간순으로 열람할 수 있습니다. 누가 언제 어떤 변경(예: 속성 추가/삭제, 링크 생성 등)을 수행했고 그것이 어떤 제안으로 승인되었는지 추적 가능하며, 필요시 특정 시점으로 되돌리거나 변경 내용을 비교(diff)할 수 있습니다. History는 온톨로지에 대한 **감사 추적(audit trail)**을 제공하여 데이터 모델 변경의 투명성과 신뢰성을 높여줍니다. 예를 들어, 한 속성이 삭제되었다면 History에 해당 commit과 “Deleted property X (by User Y)” 등의 설명이 남고, 관련된 모든 뷰/애플리케이션에 영향이 있었는지 파악할 수 있습니다 . Ontology Editor는 이처럼 **버전 관리 시스템**을 통합함으로써, 다수의 사용자가 기업의 핵심 데이터 모델을 안전하게 공동 편집할 수 있는 환경을 제공합니다.

## **주요 기능의 사용자 플로우 (엔터티 생성, 속성 정의, 관계 매핑)**

Ontology Editor의 UI는 **유도된 워크플로우(guided workflow)**를 통해 사용자가 순차적으로 온톨로지 구축 작업을 수행하도록 도와줍니다. 대표적인 사용자 여정으로 **새로운 Object Type 생성**, **속성 추가 및 매핑**, **객체 간 관계(Link) 설정**이 있으며, 각각의 흐름에서 어떤 인터랙션이 일어나는지 상세히 살펴보겠습니다.

### **새로운 Object Type 생성 플로우**

새로운 엔터티(객체 유형)를 정의하는 과정은 **단계별 생성 마법사(wizard)** 형태로 제공됩니다 . 사용자는 Ontology Editor 상단의 “New” 메뉴에서 **“Object type”**을 선택하여 생성 프로세스를 시작할 수 있습니다 . 그러면 “Create new object type”이라는 대화창이 나타나며, 몇 개의 단계에 걸쳐 필요한 정보를 입력받습니다 .

1. **백킹 데이터소스 선택**: 첫 번째 단계에서는 새 Object Type에 연계할 **데이터소스(dataset)**를 지정할지를 묻습니다 . 이미 Foundry에 적재된 데이터셋 중 이 객체의 데이터를 담고 있는 것이 있다면 여기서 선택할 수 있습니다. 데이터셋을 선택하면 마법사가 해당 데이터셋의 **스키마를 자동으로 분석**하여 Object Type의 메타데이터 필드를 미리 채워주고, 모든 컬럼을 속성으로 임시 생성해 줍니다 . 예컨대 *Employees* 테이블을 선택하면 Display Name을 “Employee”로 설정하고, 테이블의 각 컬럼명을 동일한 이름의 속성으로 자동 추가합니다. (나중 단계에서 불필요한 속성은 제거 가능) 만약 적절한 데이터셋이 없거나 비어있는 객체를 만들고자 할 경우 **“데이터소스 없이 진행”** 옵션을 선택할 수 있으며, 이 경우 나중에 데이터를 채우기 위한 빈 데이터셋이 생성됩니다 . *참고:* Foundry Object Storage V1(Phonograph) 사용 시에는 빈 데이터셋 생성 옵션을 사용할 수 없으며 반드시 데이터소스를 선택해야 합니다 .
2. **Object Type 메타데이터**: 다음 단계에서는 객체의 기본 정보를 입력합니다 . **Display Name** (단수형 표시 이름), **Plural Name** (복수형 이름), **Description** (설명), **Icon 및 색상**, **Groups** (소속 그룹) 등을 지정합니다 . 예를 들어 “항공기” 객체를 만든다면 Display Name을 “Aircraft”, Plural Name을 “Aircrafts”로 입력하고, 설명란에 용도를 기술할 수 있습니다. 아이콘은 Foundry에서 제공하는 아이콘 세트 중 선택하며, 아이콘 색상 역시 팔레트에서 골라 **해당 객체의 식별색**으로 쓸 수 있습니다 . 그룹은 객체들을 분류하기 위한 레이블로, 예를 들어 “예시 데이터” 그룹이나 “마스터 데이터” 그룹 등을 지정하여 Ontology 내 객체를 논리적으로 묶을 수 있습니다 . 그룹은 나중에 Ontology Manager의 검색 및 필터에 활용되고 Object Explorer 홈 화면에도 표시됩니다 .
3. **속성 구성**: 세 번째 단계에서는 해당 Object Type이 가질 **Properties(속성)**를 검토 및 조정합니다 . 앞 단계에서 데이터소스를 선택한 경우 이미 데이터 컬럼 기반으로 임시 속성들이 나열되어 있을 것입니다. 여기서 불필요한 속성을 제거하거나, 자동 생성되지 않은 추가 속성을 수동으로 생성할 수 있습니다 . 모든 Object Type에는 최소 한 개 이상의 속성이 필요하며, Primary Key로 사용할 속성이 있어야 합니다 . UI 상에서 **“Add property”** 또는 **“Create new property”** 등의 버튼으로 새 속성을 추가하면 속성 이름과 타입을 지정할 수 있고, **Advanced** 설정으로 Media(첨부파일)와 같이 복잡한 타입의 속성도 추가 가능합니다 (단, 이러한 고급 타입 속성은 마법사 단계에서 바로 구성되지 않고 나중에 수동 설정해야 함) . 속성 구성 단계에서는 **모든 속성 중 어떤 것을 Primary Key와 Title Key로 사용할지**도 함께 설정해야 합니다 . UI에서 Primary/Title 용도로 지정할 속성을 선택하면 해당 키 역할이 부여되며, Primary Key는 이후 객체 식별에 필수적인 고유 키로 사용되고 Title Key는 UI상에서 각 객체를 대표하는 이름으로 활용됩니다 . 예를 들어 *Employee* 객체의 Title Key를 “Full Name” 속성으로 지정하면, UI에서 개별 Employee 객체를 나타낼 때 식별자로 직원 이름이 표시됩니다 . Primary Key는 데이터셋 내 반드시 유일(unique)해야 함을 유의해야 하며, UI도 중복 키에 대해 경고를 제공합니다 . (Object Storage V2의 경우 중복 PK는 빌드 에러를 일으키며 저장이 차단됨 .)
4. **액션 생성 (선택사항)**: Object Storage V2를 사용하는 경우, 마지막 단계로 **기본 액션(Action)**들을 자동 생성하는 옵션이 제공됩니다 . 이를 활성화하면 해당 Object Type의 객체를 편집(Create/Update/Delete)하기 위한 표준 액션 세트가 생성되며, 이 액션들을 실행할 수 있는 기본 권한(사용자/그룹)을 지정할 수 있습니다 . 생성된 액션들은 나중에 필요에 따라 편집하거나 추가 액션을 정의할 수도 있습니다. (Object Storage V1 환경에서는 이 단계 없이 바로 최종 단계로 넘어갑니다.)
5. **검토 및 생성**: 모든 정보를 입력한 후 **“Create”** 버튼을 누르면 새 Object Type이 생성됩니다 . 이 때 생성된 Object Type은 일단 **임시로 브랜치에 추가된 상태**(staged)이며, 아직 온톨로지 메인에 저장(commit)되지 않은 점에 유의해야 합니다 . 생성 완료 후 Ontology Editor는 자동으로 해당 객체의 Object Type 화면(Overview 탭)으로 이동시키므로, 사용자는 방금 입력한 메타데이터와 속성들이 잘 반영되었는지 확인할 수 있습니다 . 최종적으로 상단의 **저장(Save) 또는 제안 제출** 과정을 통해 이 변경사항(새 Object Type 추가)을 온톨로지에 커밋해야 합니다 . 저장 절차는 브랜치에 변경을 확정하고, 만약 현재 브랜치가 메인이 아닐 경우 Proposals에 변경을 올려서 승인/병합을 거치게 됩니다.

만약 마법사 도중 “Create”를 눌러 일찍 종료했다면(예: 일부 단계만 채운 후 마법사 창을 닫은 경우), Object Type이 **불완전한 상태**로 생성되어 Overview 화면에 나타나지만, 해당 객체는 **필수 설정 완료 전까지 저장할 수 없습니다** . 이 경우 사용자는 수동으로 Object Type 화면에서 남은 설정(메타데이터, 데이터소스, 속성, 키 등)을 모두 완료해야 하며, UI에서도 어떤 항목이 미완성인지 **경고 표식**으로 표시해 줍니다. 모든 필드가 채워지고 나면 “Save”가 활성화되고 비로소 온톨로지에 저장할 수 있게 됩니다  .

### **속성 정의 및 매핑 플로우**

Object Type 생성 후나 기존 Object Type 편집 시, **새 속성을 정의**하거나 기존 속성을 편집하는 작업은 Ontology Editor에서 빈번하게 일어나는 인터랙션입니다. 기본적인 흐름은 다음과 같습니다.

- **새 속성 추가**: Object Type 화면의 Properties 섹션 또는 Properties 탭에서 **“Create new property”** 버튼을 클릭합니다. 그러면 속성 이름과 타입을 입력하는 작은 폼이 나타나며, 예를 들어 serialNumber라는 문자열(String) 타입 속성을 추가할 수 있습니다. 속성을 추가하면 기본 상태는 *Draft* (초안)으로 간주되며 아직 데이터 컬럼에 매핑되지 않은 상태입니다. 추가 직후 Property Editor가 열리면서 해당 속성의 상세 설정을 입력할 수 있습니다 (앞서 설명한 Display Name, 설명, 타입 등) .
- **백킹 컬럼 매핑**: 새 속성을 추가한 후 또는 기존 속성을 수정할 때, 중요한 단계는 이 **속성을 실제 데이터 컬럼과 연결(매핑)**하는 것입니다. Property Editor에서 **“Map to a column”**을 선택하면, Foundry에 연결된 데이터소스의 컬럼 목록이 드롭다운으로 제공되어 이 속성에 대응시킬 컬럼을 선택할 수 있습니다 . 예를 들어 serialNumber 속성을 inventory_dataset의 serial_no 컬럼과 매핑하면, 해당 객체의 각 인스턴스는 해당 데이터셋 행의 serial_no 값을 이 속성의 값으로 갖게 됩니다. 만약 데이터소스에 아직 해당 컬럼이 없다면, Pipeline Builder 등에서 데이터 준비 단계를 거쳐 컬럼을 추가하거나, Foundry의 데이터 모델을 수정한 후 다시 매핑해야 합니다.
- **속성 메타데이터 편집**: Property Editor에서 속성의 표시 이름, 설명, API Name, 키 여부, 가시성 등을 설정합니다 . 특히 **Primary Key**나 **Title Key**로 지정할 경우 해당 Object Type 내 다른 속성의 키 설정이 자동 해제되므로 한 번에 하나씩만 지정되며, UI가 이를 관리합니다. 또한 **Status**를 *Experimental*로 지정하면 UI에 주황색 배지가 표시되어 실험적임을 나타내고, *Deprecated*로 지정하면 회색 또는 붉은 배지로 나타나 사용자에게 사용 자제를 권고합니다 (Active는 별도 배지 없이 기본 상태로 표시) . **Visibility** 설정에서 *Hidden*으로 지정한 속성은 Object Explorer 등의 기본 뷰에 숨겨지며, 필요한 경우에만 Advanced 옵션을 켜야 보이도록 제어됩니다 .
- **유효성 검사 및 피드백**: 사용자가 속성의 타입이나 키 등을 수정하면 Ontology Editor는 즉각적인 검증을 수행하여 문제가 있을 경우 **경고/에러 메시지**를 표시합니다. 예를 들어 속성의 데이터 타입(Base Type)을 변경했는데 백킹 데이터 컬럼 타입과 호환되지 않는다면 UI 상에 오류를 나타내고 저장을 막습니다 . 또, Primary Key를 변경하려 하면 이미 데이터에 중복 값이 존재하지 않는지 확인해야 하며, Foundry 2세대 스토리지에서는 중복 PK가 발견되면 **파이프라인 에러**가 발생하므로 저장 전에 경고해줍니다 . 속성을 삭제하려는 경우에도 “Delete property” 클릭 시 **확인 대화창**이 뜨며, 이 속성을 사용하는 모든 뷰/애플리케이션에 영향이 갈 수 있음을 경고합니다 . Active 상태 속성은 삭제 옵션 자체가 비활성화되어 있고, 삭제하려면 먼저 속성 상태를 Deprecated로 내리는 등의 조치를 해야 합니다 . 이러한 피드백 메시지와 제한은 **사용자 실수를 예방**하고 온톨로지 무결성을 유지하도록 설계되었습니다.
- **저장(commit)**: 속성 추가/수정 후에는 Object Type 수준에서 **변경사항 저장**을 해야 합니다. 여러 속성을 연달아 편집한 경우, 해당 Object Type Overview 화면이나 상단 바에 “변경 사항 있음”이라는 인디케이터가 나타나고, 이를 눌러 변경 내용을 저장(commit)할 수 있습니다. 이때도 브랜치/제안 개념이 적용되어, 만약 메인 브랜치에서 작업 중이었다면 바로 메인 온톨로지에 반영되고, 별도 브랜치라면 Proposal 생성/업데이트로 이어집니다.

요약하면, Ontology Editor의 속성 편집 플로우는 **속성 정의 → 데이터 매핑 → 메타데이터 설정 → 검증 및 저장** 순으로 진행되며, UI가 각 단계에서 사용자에게 필요한 정보와 피드백을 제공하여 데이터모델링 작업을 안내해줍니다.

### **객체 간 관계(Link) 매핑 플로우**

Ontology Editor에서는 데이터 모델의 **관계성**을 Link Type으로 관리하므로, 두 Object Type 사이의 관계를 맺는 것도 중요한 사용자 여정입니다. 새로운 **Link Type 생성** 흐름은 Object Type 생성처럼 전용 마법사가 존재합니다 .

사용자는 상단 “New” 메뉴에서 **“Link type”**을 선택하거나, 사이드바의 Link Types 섹션에서 **“New link type”** 버튼을 눌러 생성 프로세스를 시작합니다 . 또는 Object Type Overview의 Link Type Graph 위에서 **“Create new link type”** 옵션을 사용해 해당 객체와 연결할 새 링크를 만들 수도 있습니다 .

Link Type 생성 마법사는 주로 **세 가지 단계**로 구성됩니다 :

1. **관계 유형 선택**: 먼저 정의하려는 관계의 **카디널리티(cardi­nality)** 및 저장 방식을 선택합니다 . UI에서는 **Foreign Key**, **Dataset**, **Object Type** 세 가지 옵션을 제시하며, 사용자가 모델링하려는 관계에 가장 맞는 방식을 고를 수 있습니다 .
    - *Foreign Key*는 일반적인 **일대일 (1:1)** 또는 **다대일 (Many:1)** 관계에 해당하며, 한 객체의 외래키 속성을 통해 다른 객체를 참조하는 방식입니다 .
    - *Dataset*은 **다대다 (Many:Many)** 관계에 쓰이며, 별도의 조인 테이블(중간 테이블) 데이터셋으로 두 객체 간 링크를 관리합니다 .
    - *Object Type*은 **객체 기반 링크**로서, 링크 자체를 하나의 Object Type(중간 객체)으로 모델링하는 고급 방식입니다 . (예: Flight와 Aircraft 사이에 Flight Manifest 객체를 두어 링크의 추가 메타데이터까지 관리하는 패턴 .)
    
    사용자는 예를 들어 “항공기 – 비행편” 관계를 만든다면 항공기 한 대가 여러 비행에 투입될 수 있고, 한 비행에 항공기 한 대씩 배정된다고 가정해 **One-to-Many** 구조로 판단, Foreign Key 방식을 선택할 수 있습니다 (항공기 객체의 PK ↔ 비행 객체의 FK 연결) . Many-to-Many가 필요한 경우 Dataset 방식 선택, 추후 링크 메타데이터가 필요하면 Object-backed 링크를 고려합니다.
    
2. **링크 대상 및 자원 설정**: 다음으로, 어떤 **두 Object Type을 연결**할지 그리고 연결을 뒷받침할 리소스를 지정합니다 .
    - Foreign Key를 선택한 경우, **Primary Key 쪽 객체**와 **Foreign Key 쪽 객체**를 각각 지정하고, 해당 객체들의 어느 속성을 연결할지 선택합니다 . UI는 두 객체를 선택하면 자동으로 **조건이 일치하는 외래키 후보**를 찾아주기도 합니다 (예: 이름이 같고 타입이 같은 속성이 있으면 자동 매핑) . 예시 시나리오로 Aircraft 객체의 Primary Key *Tail Number*와 Flight 객체의 속성 중 *Flight Tail Number*를 매칭하여 링크를 만드는 경우, UI에서 Aircraft를 PK측, Flight를 FK측으로 지정하고 Flight의 FK 속성에 Flight Tail Number, Aircraft 쪽 PK는 자동으로 Tail Number로 선택됩니다 .
    - Dataset 방식을 선택했다면, **조인용 데이터셋**을 지정해야 합니다 . 예컨대 *Aircraft_Flight_Link*라는 조인 테이블이 있고 그 안에 aircraft_id, flight_id 두 컬럼이 있다고 하면, Link Type 마법사에서 해당 데이터셋을 선택하고 좌우 객체로 Aircraft와 Flight를 지정한 뒤, 각 객체의 Primary Key에 대응되는 컬럼으로 aircraft_id->Aircraft.ID, flight_id->Flight.ID를 매핑합니다 . Foundry는 편의를 위해 조인 테이블이 없는 경우 **Generate join table** 옵션으로 두 객체의 PK를 갖는 스키마를 자동 생성해주기도 합니다 .
    - Object-backed 링크의 경우에는 **사전 준비된 객체와 링크**를 활용합니다. 마법사에서는 좌우 두 객체 (예: Aircraft, Flight)와 이들을 연결할 중간 Object Type (예: Flight Manifest)을 선택하고, 이미 존재하는 두 개의 다대일 링크(Aircraft–Manifest, Flight–Manifest)를 지정하면 세 객체가 하나의 링크 타입으로 통합됩니다 . Object-backed 방식은 설정이 다소 복잡하지만, Link 자체에 속성을 추가하거나 세밀한 권한 제어(Restricted View 등)를 적용해야 할 때 유용합니다 .
3. **링크 명칭 설정**: 마지막 단계에서는 **Link Type의 이름**을 정의합니다 . 여기에는 **Display Name**과 **API Name**을 양쪽 방향에 대해 입력하게 되어 있습니다 . Display Name은 UI에 표시될 관계 이름으로, 각각 “[Object A]의 [Object B]들” 관계와 “[Object B]에 [Object A]가” 관계 식으로 서술합니다. 앞서 예를 든 Flight-Aircraft 관계의 경우 Flight에서 Aircraft를 가리키는 쪽을 “Assigned Aircraft” (비행편에 할당된 항공기)로, 반대쪽 Aircraft에서 Flight들을 가리키는 쪽을 “Flights” 등으로 정할 수 있습니다 . API Name은 이 Display Name을 기반으로 자동 생성되지만, 개발 편의나 명명 규칙에 따라 수정 가능합니다 . 예컨대 “Assigned Aircraft”의 API Name은 assignedAircraft로 생성되어 코드나 파이프라인에서 Flight.assignedAircraft.get() 형태로 객체간 연관 데이터를 가져오는 식으로 활용됩니다 . API Name은 소문자 영숫자로 100자 이내, 해당 객체 내 고유해야 함 등 몇 가지 제약이 있습니다 .

모든 단계를 마치고 **Submit/Create**를 완료하면, 새 Link Type이 생성되어 사이드바 Link Types 목록과 관련 Object Type의 Link 그래프에 반영됩니다 . 생성된 링크 역시 Object Type과 마찬가지로 **저장** 과정을 거쳐야 온톨로지에 영구 반영됩니다 . 링크를 생성하면 Foundry 내부적으로 링크 데이터에 대한 파이프라인(인덱싱)이 설정되어, Object Explorer 등에서 두 객체 간 탐색이나 Join 연산 없이도 바로 관계를 활용할 수 있게 됩니다.

Link 생성 후에는 Link Type 화면에서 필요시 추가 설정(예: 링크에 부가 속성 추가, 링크 편집 기능 활성화 등)을 할 수 있고, 잘못 설정된 경우 **편집(Edit link type)** 화면에서 링크의 키 매핑이나 조인 방식을 변경할 수 있습니다  . 예를 들어 기존 Foreign Key 링크를 Object-backed로 **업그레이드**해야 한다면, Link Type 설정의 Join Method를 바꾸고 중간 객체 타입을 지정하는 과정을 거쳐 변환할 수 있으며, UI가 기존 링크 데이터를 새로운 구조로 이관하도록 지원합니다  .

### **액션 및 함수 설정 플로우 (개요)**

Ontology Editor를 통해 **Action Type**(예: 승인 요청 액션, 상태 변경 액션 등)과 **Function**(사용자 정의 비즈니스 로직 함수)도 추가할 수 있지만, 이들의 생성은 주로 별도의 편집기(액션 에디터 혹은 코드 에디터)에서 이루어집니다. 예를 들어 *새 Action Type 생성*을 선택하면 특정 Object Type에 붙는 액션을 정의하는 설정 화면이 뜨고, 액션 이름, 설명, 트리거 조건, 파라미터, 동작할 함수 등을 연결합니다. 이 때 만약 새로운 함수를 작성해야 한다면 Foundry의 Functions 코드 레포지토리로 이동하여 TypeScript 또는 Python으로 함수를 구현해야 합니다 . 작성된 함수는 Ontology Editor의 Functions 섹션에 자동 등록되며, UI에서 해당 함수의 버전 관리, 배포 상황을 모니터링할 수 있습니다 . Action과 Function의 생성/편집 흐름은 개발자 지식이 필요한 부분이므로 일반 비기술 사용자보다는 데이터 엔지니어나 애플리케이션 개발자가 주로 수행하며, Ontology Editor는 이들을 관리하고 Object Type에 연결하는 **허브** 역할을 합니다. 중요한 것은, Palantir Foundry의 Ontology 개념 내에서 **데이터 구조 (객체/속성/링크)**와 **데이터 동작 (액션/함수)**이 한 곳에서 유기적으로 연결되어 있다는 점이며, UI 상에서도 객체 페이지에서 곧바로 액션/함수를 보고 편집할 수 있는 **맥락 지향 인터랙션** 흐름을 제공한다는 것입니다.

### **변경사항 저장 및 배포**

Ontology Editor에서 수행한 모든 변경 작업은 **명시적 저장(commit)** 액션을 통해서만 온톨로지 본판에 반영됩니다 . 사용자가 Object Type이나 Link Type 등을 생성/편집하면, 화면 우상단이나 브랜치 표시 영역에 **저장 아이콘** 혹은 **“Save changes”** 버튼에 변경 건수 표시가 나타납니다. 예를 들어 “Save (3 changes)”와 같이, 아직 커밋되지 않은 3건의 변경사항이 있음을 알려줍니다.

저장 버튼을 누르면 **변경 요약** 다이얼로그가 뜨면서 어떤 변경이 포함되는지 보여주고, 사용자는 변경 설명 메시지를 작성한 후 저장을 확정할 수 있습니다. 이때 현재 작업 중인 브랜치가 **Main(메인)**인지 **Feature 브랜치**인지에 따라 다음 동작이 다릅니다:

- *메인 브랜치 작업:* 변경사항이 즉시 메인 온톨로지에 적용되고, 해당 변경 기록이 History에 남습니다. Palantir Foundry는 이러한 스키마 변경에 따라 데이터 인덱싱 파이프라인을 자동 실행하여 최신 상태를 유지합니다.
- *별도 브랜치 작업:* 변경사항이 해당 브랜치에 커밋되고 **Proposals 뷰에 제안**으로 등록됩니다 . 이 제안은 지정된 승인자나 관리자에 의해 Foundry 내에서 검토를 거쳐 승인되면 메인에 병합됩니다. UI 상에서는 Proposal이 pending 상태로 사이드바 *Proposals*에 리스트되고, 승인 대기 중임을 아이콘/색상으로 표시합니다.

승인 프로세스 중에도 Ontology Editor 사용자는 제안 상태를 실시간으로 확인할 수 있고, 필요하면 추가 커밋을 동일 브랜치에 쌓아 하나의 Proposal에 여러 변경을 포함시킬 수도 있습니다. 반대로 문제가 발견되면 Proposal을 **Reject(거절)**하거나 브랜치에서 변경을 **Revert(되돌리기)**할 수도 있으며, 이러한 협업 워크플로우가 Ontology Editor UI에 녹아 있습니다.

이러한 저장/배포 흐름은 사용자가 안전하게 온톨로지 변화를 다루도록 하는 UX 패턴입니다. 즉시 적용이 아닌 **임시 저장 -> 검토 -> 승인** 절차를 거치게 함으로써, 대규모 조직에서 데이터 스키마 변경이 끼치는 영향을 최소화하고 품질을 담보합니다. UI에서 단계마다 피드백(예: “성공적으로 저장됨”, “승인 대기 중” 등의 배너/토스트 메시지)을 제공하여 사용자가 현재 변경의 **상태**를 명확히 인지할 수 있게 해줍니다.

## **사용자 인터페이스의 시각적 스타일 분석**

Palantir Foundry Ontology Editor의 UI는 팔란티어의 전반적인 디자인 시스템을 따르며, **미니멀하고 실용적인 시각적 스타일**을 구현하고 있습니다. 주요 스타일 요소를 정리하면 다음과 같습니다:

- **컬러 시스템:** 전체적으로 **밝은 테마(light theme)** 기반으로 화이트/라이트 그레이 계열의 배경색과 어두운 텍스트를 사용하여 가독성을 확보하고 있습니다. 사이드바와 상단바는 약간 짙은 회색 톤으로 구분되며, 콘텐츠 영역은 흰색 바탕에 검은색/짙은 회색 텍스트로 구성됩니다. 인터랙티브 요소나 하이라이트에는 Palantir의 액센트 컬러(블루 계열)가 사용됩니다. 예를 들어 상단 **New 버튼**을 클릭하면 드롭다운 메뉴에서 선택 항목이 파란 하이라이트로 표시되고, Proposals 대기열에 변경사항이 있을 경우 상단 아이콘에 파란 뱃지가 나타나는 식입니다. 또한 **상태 표시**나 **태그**에는 명도 대비가 높은 색상들이 적용됩니다. *Experimental* 상태 속성은 주황색 라벨로, *Deprecated*는 회색 라벨로 나타나고, Primary Key 속성은 보라색 아이콘/텍스트로, Title Key는 녹색으로 강조 표시되어 사용자가 한눈에 인지할 수 있습니다. 이러한 색상 부여는 UI 곳곳에 일관되게 적용되어, 예를 들어 속성 테이블에서도 Primary Key 컬럼에는 보라색 키 아이콘이, Hidden 속성에는 아이콘이 흐릿하게 표시되는 등의 패턴이 있습니다 . 오류나 경고 상황에서는 전형적인 빨강/노랑 계열의 강조색과 아이콘이 사용됩니다. 예컨대 속성 타입 불일치 에러 시 해당 필드 가장자리가 빨간색으로 강조되고 마우스오버 시 에러 툴팁이 나타납니다 . 중요한 경고 (예: 데이터 손실 가능성 경고)는 노란색 삼각형 아이콘과 함께 대화창 또는 배너로 표시되어 주의를 환기시킵니다 .
- **타이포그래피:** 폰트는 모던한 **산세리프(sans-serif)** 계열을 사용하며 (Palantir 자체 UI 폰트 또는 유사한 Open Sans 등), 크기와 굵기를 통해 계층 구조를 전달합니다. 화면 제목이나 섹션 헤더는 비교적 크고 굵게 표시되어 사용자 시선의 앵커가 되고, 세부 리스트 항목이나 설명 텍스트는 작은 크기로 단정하게 정렬됩니다. 예를 들어 Object Type Overview 화면에서 객체 Display Name은 큰 글씨로 상단에 표시되고 바로 아래 Description은 조금 작은 회색 글씨로 표시되어 계층을 이룹니다. 폰트 색상은 기본적으로 **고명도 대비**를 유지하여 데이터량이 많아도 읽기 쉽도록 했습니다. 또한 표나 폼 내 레이블은 약간 강조(Bold)하여 값과 시각적으로 구별하고, 긴 설명이나 툴팁 텍스트는 기울임이나 옅은 색을 사용해 눈에 거슬리지 않게 디자인되었습니다. 전반적으로 **가독성(Readability)**을 최우선으로 한 글꼴 크기와 줄 간격(line-height)이 적용되어, 복잡한 데이터 모델 정보도 UI상에서 쉽게 읽히고 이해되도록 배려하고 있습니다.
- **레이아웃과 구성:** Ontology Editor는 **두세 개의 패널로 분할된 레이아웃**을 일관되게 활용합니다. 좌측 내비게이션, 우측 콘텐츠 같은 2열 구조나, 속성 편집기의 좌측 리스트 + 우측 상세패널 같은 **마스터-디테일 패턴**이 대표적입니다. 이러한 레이아웃은 창 크기에 따라 유연하게 반응하며(responsive design), 작은 화면에서는 사이드바가 자동으로 접히는 등 **반응형 UI** 요소도 갖추고 있습니다. 각 패널이나 카드 간에는 적절한 여백과 구분선이 사용되어 정보가 시각적으로 구획화되어 보입니다. 예를 들어 Overview 섹션 카드들은 그림자나 경계선 없이도 충분한 패딩과 타이틀 폰트 크기로 나눠져 있어 깨끗한 인상을 줍니다. 또한 UI 상의 **정렬과 아이콘 활용**도 일관적입니다. 리스트 뷰에서는 텍스트 좌측에 일률적으로 아이콘(예: 속성 타입 아이콘, 눈 아이콘 등)이 배치되고, 액션 버튼(예: 편집, 삭제)은 우측에 어둡게 나타나며, 행에 마우스를 오버하면 해당 아이콘이 강조되어 나타나는 식입니다. 이런 **일관된 레이아웃과 상호작용** 패턴 덕분에 처음 쓰는 사용자도 각 요소의 용도를 예측하기 쉽습니다.
- **피드백 메시지 및 상태 표시:** Ontology Editor는 사용자 조작에 대한 즉각적인 피드백을 다양한 방식으로 제공합니다. **툴팁**은 아이콘 또는 텍스트에 마우스를 올리면 나타나서 해당 항목의 의미를 설명하며, 예를 들어 속성 Status 옆의 작은 아이콘에 “Experimental: 이 속성은 시험 단계입니다” 같은 툴팁이 표시됩니다. **토스트(toast) 알림**은 사용자 작업 결과를 알려주는 데 사용됩니다. 객체 저장 성공, 제안 제출 완료 등의 이벤트 후 우상단에 잠시 나타났다 사라지는 토스트 메시지로 피드백을 전달하며, 색상과 아이콘으로 성공(green checkmark), 오류(red x), 경고(orange exclamation) 등을 구분합니다. **다이얼로그 및 인라인 경고**도 적극 활용되는데, 앞서 언급한 속성 삭제 시 컨펌 대화상자, 저장 시 변경 요약 창 등이 대표적입니다 . 폼 필드 단위로는 **인라인 검증 메시지**가 붉은 글씨로 표시되어 사용자의 즉각 수정을 유도합니다 (예: “ID는 소문자와 숫자, 대시만 사용할 수 있습니다”와 같은 메시지). 또한 상단바 브랜치명 옆에는 현재 브랜치가 **메인과 ahead/doverging 상태인지** 아이콘으로 나타나, 사용자가 저장/배포 상황을 인지하도록 돕습니다. 예컨대 브랜치에 커밋이 있고 아직 메인에 병합 안 된 경우 브랜치 아이콘이 점등되거나 “1 proposal pending”이라는 배지가 표시됩니다.

이러한 시각적 스타일 요소 전반을 통해 Ontology Editor는 **산업용 엔터프라이즈 소프트웨어**로서 신뢰성과 명료함을 전달합니다. 화려한 장식이나 불필요한 그래픽을 배제하고, 데이터 모델링 업무에 최적화된 최소한의 색상과 타이포그래피, 레이아웃만을 사용함으로써 사용자들이 **컨텐츠에 집중**할 수 있게 합니다. 동시에 각종 피드백과 상태 표현에서 적절한 시각적 강조를 주어 **사용자 경험(UX)** 측면에서도 효율성과 안전성을 모두 충족하고 있습니다.

## **UX 패턴 및 사용자 친화성 요소**

Ontology Editor의 UX 설계에는 데이터 엔지니어/모델러뿐 아니라 **업무 도메인 전문가**들도 사용하기 쉽도록 배려한 여러 패턴이 녹아 있습니다:

- **워크플로우 중심 설계:** 앞서 설명한 객체/링크 생성 마법사처럼, 복잡한 설정 작업을 단계별로 쪼개어 **마법사 형식으로 안내**하는 패턴이 두루 적용되어 있습니다 . 사용자는 한 번에 하나의 결정만 내리면 되고, 이전/다음 단계를 차례로 거치며 완성할 수 있으므로 온톨로지 구조에 대한 사전 지식이 많지 않아도 자연스럽게 따라갈 수 있습니다. 예를 들어 Link Type 생성 시 관계 유형→객체 선택→명칭 지정 순으로 흐름을 유도하여 사용자가 놓치기 쉬운 세부 설정까지 모두 마치도록 합니다.
- **검색 및 바로가기 활용:** Ontology Editor는 온톨로지 규모가 클 때를 대비해 **강력한 검색 및 필터 기능**을 제공합니다. 상단 글로벌 검색창에서는 객체 이름은 물론 **별칭(Alias)**이나 **RID(고유 식별자)**로도 검색이 가능하며, 심지어 그룹, 속성까지 통합 검색하여 해당 편집 화면으로 바로 이동할 수 있습니다 . 사이드바의 각 섹션(예: Object Types, Link Types 등)에서도 필터를 제공해 수십, 수백개의 항목 중 원하는 것을 실시간으로 추려볼 수 있습니다. 이러한 검색 중심 UX는 사용자가 복잡한 트리 구조 내비게이션을 일일이 하지 않고도 **원하는 지점에 점프**할 수 있게 해주며, 생산성을 크게 높입니다.
- **사용자별 맞춤 환경:** Discover 홈 화면의 **구성 커스터마이징**을 비롯해, Ontology Editor는 사용자별 선호에 맞게 UI를 맞춤화할 수 있는 요소가 존재합니다 . 중요하게 생각하는 Object Type을 즐겨찾기하여 홈에 배치한다거나, 자신만의 그룹을 만들어 관련 객체들을 모아본다거나 하는 식으로 **개인화 기능**이 제공됩니다. 또한 각 사용자 권한에 따라 **Ontology Editor 역할**이 구분되어, 편집 권한이 없는 사용자는 Viewer 모드로 항목을 보기만 할 수 있고, 편집자는 Editor 모드로 모든 기능을 사용하도록 제어됩니다 . 이를 통해 초보 사용자는 복잡한 편집 옵션에 혼동되지 않고 필요한 조회만 할 수 있으며, 전문가 사용자는 풀 기능을 활용할 수 있어 **사용자 수준에 맞는 UX**를 제공합니다.
- **일관성과 학습 용이성:** Ontology Editor는 Foundry 내 다른 툴(예: Workshop, Quiver 등)과 디자인 언어를 공유하여 **일관된 사용자 경험**을 줍니다. 버튼 스타일, 아이콘셋 (Palantir 자체 아이콘들), 패널 구조 등이 플랫폼 전반에 걸쳐 통일되어 있어, 하나의 Foundry 애플리케이션에 익숙하면 다른 부분도 쉽게 배울 수 있습니다. 예를 들어 Foundry Workshop에서 모듈을 편집하던 사용자는 Ontology Editor의 양식 구성이나 저장 프로세스도 비슷하게 느끼게 됩니다. 또한 Undo/Redo, 단축키(Ctrl+S로 저장 등) 같은 **표준 UX 패턴**도 지원되어 사용자 편의를 높입니다.
- **안전 장치와 가이드:** 데이터 모델 변경은 민감한 작업이므로, Ontology Editor는 여러 **UX 안전장치**를 갖추고 있습니다. 앞서 언급한 삭제 확인, 상태에 따른 편집 잠금, 저장 전 검토 외에도, **예방적 안내 메시지**를 통해 실수를 줄입니다. 예를 들어 Primary Key 설정 단계에서 “중복 키가 없는지 확인하세요”라는 힌트를 표기하거나 , 그룹 필드에 새 그룹 이름을 입력하면 “입력하면 새 그룹이 생성됩니다” 등의 안내를 실시간으로 보여줍니다 . 또한 사용자가 혼동할 수 있는 개념(예: Object vs Link vs Value Type)을 UI 용어와 도움말을 통해 구분지어 주며, 각 화면 상단에는 해당 기능에 대한 **도움말 링크**(팔란티어 공식 문서)가 있어 언제든 참고할 수 있게 합니다.
- **협업 지원:** Ontology Editor는 여러 사용자가 동시에 온톨로지를 발전시킬 수 있도록 **협업 UX**에도 신경쓰고 있습니다. 브랜치와 Proposal 개념은 마치 개발자의 git workflow처럼 설계되어, UI에서도 제안에 코멘트를 남기거나 변경을 비교하는 기능이 지원됩니다. 또한 누군가 동일 객체를 편집 중이면 락을 걸거나 충돌을 알려주는 메커니즘이 있어 충돌 편집을 방지합니다. 이러한 기능들은 큰 조직에서 **협업 안정성**을 높이고 사용자 경험을 매끄럽게 만듭니다.

以上과 같이, Palantir Foundry Ontology Editor는 강력한 기능들을 갖추는 동시에 **UI/UX 측면에서 세밀한 배려**를 통해 사용자 친화적인 데이터 모델링 환경을 제공하고 있습니다. 공식 문서와 데모 영상에서도 강조되듯이, 코드를 몰라도 **포인트앤클릭(point-and-click)** 조작만으로 온톨로지를 구축할 수 있고, 그 결과를 바로 분석 애플리케이션에 활용할 수 있다는 것이 Foundry Ontology의 큰 장점입니다 . Ontology Editor의 화면 구성과 사용자 여정은 이러한 목적에 맞게 설계되었으며, **명확한 구조와 실시간 피드백**으로 사용자의 실수를 줄이고 학습곡선을 낮춰 주고 있습니다.

## **참고 자료 및 출처**

- Palantir Foundry 공식 문서 – Ontology Manager Overview 등
- Palantir Foundry 공식 문서 – Create an object type 등
- Palantir Foundry 공식 문서 – Create a link type 등
- Palantir Foundry 공식 문서 – Edit object type properties 등
- Palantir Foundry 공식 문서 – Ontology Proposals
- Medium 블로그: *Foundational Ontologies in Palantir Foundry* (개념 설명)
- Botsnova Labs 블로그: *Palantir Foundry의 Ontology 모듈 심층 연구* (배경 및 역할 설명)
- Palantir 공개 데모 영상: *Foundry Ontology & Object Explorer* (UI 시연)
    
    *(모든 인용은 Palantir 공식 문서 및 공개 자료에서 발췌)*